package org.mvnsearch.boot.npm.export.generator;

import org.intellij.lang.annotations.Language;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ValueConstants;

import java.lang.reflect.Field;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Controller JavaScript Stub generator
 *
 * @author linux_china
 */
@SuppressWarnings("StringConcatenationInsideStringBufferAppend")
public class ControllerJavaScriptStubGenerator extends BaseGenerator {

    public ControllerJavaScriptStubGenerator(Class<?> controllerClass) {
        super(controllerClass);
    }

    public String generate(String baseUrl) {
        @Language("JavaScript")
        String global = "// Don't edit this file because it was generated by Spring Boot App!!!\n" +
                "const axios = require('axios');\n" +
                "\n" +
                "let isBrowser = new Function('try {return this===window;}catch(e){ return false;}');\n" +
                "let isNode = new Function('try {return this===global;}catch(e){return false;}');\n" +
                "\n" +
                "axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n" +
                "\n" +
                "/**\n" +
                " * @param uri {string}\n" +
                " * @param pathVariables {object}\n" +
                " * @return {string}\n" +
                " */\n" +
                "function formatUri(uri, pathVariables) {\n" +
                "    let newUri = uri;\n" +
                "    for (const name in pathVariables) {\n" +
                "        newUri = newUri.replace('*{' + name + '}', pathVariables[name])\n" +
                "                .replace('{' + name + '}', pathVariables[name])\n" +
                "    }\n" +
                "    return newUri;\n" +
                "}\n\n";
        @Language(value = "JavaScript", suffix = "}")
        String classDeclare = "/**\n" +
                " " +
                "* @version $version\n" +
                " " +
                "*/\n" +
                "class XxxxController {\n" +
                "    constructor() {\n" +
                "        if (isBrowser()) {\n" +
                "            this.baseUrl = '';\n" +
                "        } else {\n" +
                "            this.baseUrl = 'http://localhost:8080'\n" +
                "        }\n" +
                "    }\n" +
                "    /**\n" +
                "     * default for TypeScript\n" +
                "     * @returns {XxxxController}\n" +
                "     */\n" +
                "    get default() {\n" +
                "        return this;\n" +
                "    }\n" +
                "\n" +
                "    /**\n" +
                "     * set base url\n" +
                "     * @param baseUrl base url\n" +
                "     * @returns {XxxxController}\n" +
                "     */\n" +
                "    setBaseUrl(baseUrl) {\n" +
                "        this.baseUrl = baseUrl;\n" +
                "        return this;\n" +
                "    }\n" +
                "\n" +
                "    /**\n" +
                "     * set JWT Token\n" +
                "     * @param token token token\n" +
                "     * @return {XxxxController}\n" +
                "     */\n" +
                "    setJwtToken(token) {\n" +
                "        this.jwtToken = token;\n" +
                "        return this;\n" +
                "    }\n" +
                "\n" +
                "    /**\n" +
                "     * set config filter\n" +
                "     * @param filter {function}\n" +
                "     * @return {XxxxController}\n" +
                "     */\n" +
                "    setConfigFilter(filter) {\n" +
                "        this.configFilter = filter;\n" +
                "        return this;\n" +
                "    }\n\n";
        StringBuilder builder = new StringBuilder();
        builder.append(global);
        String version = new SimpleDateFormat("yyyy.MM.dd").format(new Date());
        String newClassDeclare = classDeclare
                .replaceAll("XxxxController", jsClassName)
                .replace("$version", version)
                .replace("http://localhost:8080", baseUrl);
        builder.append(newClassDeclare);
        for (JsHttpStubMethod jsHttpStubMethod : jsHttpStubMethods) {
            builder.append(toJsCode(jsHttpStubMethod, "    ") + "\n");
        }
        builder.append("}\n\n");
        builder.append("module.exports = new " + jsClassName + "();\n\n");
        builder.append(typedefs());
        return builder.toString();
    }


    public String toJsCode(JsHttpStubMethod stubMethod, String indent) {
        StringBuilder builder = new StringBuilder();
        builder.append(indent).append("/**\n");
        //description
        if (stubMethod.getDescription() != null && !stubMethod.getDescription().isEmpty()) {
            builder.append(indent).append(" * " + stubMethod.getDescription() + "\n");
        } else {
            builder.append(indent).append(" *\n");
        }
        //@deprecated
        if (stubMethod.isDeprecated()) {
            builder.append(indent).append("* @deprecated\n");
        }
        for (JsParam param : stubMethod.getParams()) {
            if (param.isFromRequestSide()) {
                if (param.isRequired()) {
                    builder.append(indent).append(" * @param {" + param.getJsType() + "} " + param.getName() + "\n");
                } else {
                    //default value
                    if (param.getDefaultValue() != null && !param.getDefaultValue().isEmpty() && !param.getDefaultValue().equals(ValueConstants.DEFAULT_NONE)) {
                        builder.append(indent).append(" * @param {" + param.getJsType() + "} [" + param.getName() + "=" + param.getDefaultValue() + "]\n");
                    } else {  //optional
                        builder.append(indent).append(" * @param {" + param.getJsType() + "} [" + param.getName() + "]\n");
                    }
                }
                JSDocTypeDef jsDocTypeDef = param.getJsDocTypeDef();
                if (jsDocTypeDef != null) {
                    this.customizedTypeDefMap.put(jsDocTypeDef.getName(), jsDocTypeDef);
                }
            }
        }
        String jsReturnType = stubMethod.getJsReturnType();
        if (stubMethod.getJsDocTypeDef() == null && jsReturnType.contains("_")) {
            this.javaBeanTypeDefMap.put(stubMethod.getReturnType(), jsReturnType);
        }
        if (stubMethod.isResultNullable()) {
            jsReturnType = "(" + jsReturnType + "|null)";
        }
        builder.append(indent).append(" * @return {Promise<" + jsReturnType + ">}\n");
        builder.append(indent).append(" */\n");
        builder.append(indent).append(stubMethod.getName() + "(");
        if (!stubMethod.getParams().isEmpty()) {
            String paramsDeclare = stubMethod.getParams().stream()
                    .filter(JsParam::isFromRequestSide)
                    .map(JsParam::getName)
                    .collect(Collectors.joining(", "));
            builder.append(paramsDeclare);
        }
        builder.append(") {\n");
        builder.append(indent).append("  let config = {\n");
        if (stubMethod.hasPathVariable()) {
            builder.append(indent).append("    url: this.baseUrl + formatUri('" + stubMethod.getPath() + "'," + formatPathVariables(stubMethod) + "),\n");
        } else {
            builder.append(indent).append("    url: this.baseUrl + '" + stubMethod.getPath() + "',\n");
        }
        builder.append(indent).append("    headers: " + formatHttpHeaders(stubMethod) + ",\n");
        if (stubMethod.isPlainBody()) {
            builder.append(indent).append("     data: " + stubMethod.getRequestBodyParam().getName() + ",\n");
        } else {
            if (stubMethod.hasRequestParam()) {
                if (stubMethod.getMethod().equals(RequestMethod.GET)) {
                    builder.append(indent).append("    params: " + formatRequesterParams(stubMethod) + ",\n");
                } else {
                    builder.append(indent).append("    data: " + formatRequesterParams(stubMethod) + ",\n");
                }
            }
        }
        builder.append(indent).append("    method: '" + stubMethod.getMethod().name().toLowerCase() + "'\n");
        builder.append(indent).append("  };\n");
        builder.append(indent).append("  if (this.jwtToken != null) { config.headers['Authorization'] = 'Bearer ' + this.jwtToken; }\n");
        builder.append(indent).append("  if (this.configFilter != null) { config = this.configFilter(config); }\n");
        Class<?> returnType = stubMethod.getReturnType();
        if (returnType.isAssignableFrom(Integer.class) || returnType.isAssignableFrom(int.class)) {
            builder.append(indent).append("  return axios(config).then(response => {return parseInt(response.data);});\n");
        } else if (returnType.isAssignableFrom(Float.class)
                || returnType.isAssignableFrom(float.class)
                || returnType.isAssignableFrom(Double.class)
                || returnType.isAssignableFrom(double.class)) {
            builder.append(indent).append("  return axios(config).then(response => {return parseFloat(response.data);});\n");
        } else {
            builder.append(indent).append("  return axios(config).then(response => {return response.data;});\n");
        }
        builder.append(indent).append("}\n");
        return builder.toString();
    }

    public String formatPathVariables(JsHttpStubMethod stubMethod) {
        return "{" + stubMethod.getParams().stream()
                .filter(param -> param.getPathVariableName() != null)
                .map(param -> "\"" + param.getPathVariableName() + "\": " + param.getName())
                .collect(Collectors.joining(", ")) + "}";
    }

    public String formatHttpHeaders(JsHttpStubMethod stubMethod) {
        StringBuilder builder = new StringBuilder();
        builder.append("{");
        if (stubMethod.getRequestContentType() != null) {
            builder.append("\"Content-Type\": \"" + stubMethod.getRequestContentType() + "\"");
        }
        if (stubMethod.hasHttpHeader()) {
            builder.append(",").append(stubMethod.getParams().stream()
                    .filter(param -> param.getHttpHeaderName() != null)
                    .map(param -> "\"" + param.getHttpHeaderName() + "\": " + param.getName())
                    .collect(Collectors.joining(", ")));
        }
        builder.append("}");
        return builder.toString();
    }

    public String formatRequesterParams(JsHttpStubMethod stubMethod) {
        return "{" + stubMethod.getParams().stream()
                .filter(param -> param.getRequestParamName() != null)
                .map(param -> "\"" + param.getRequestParamName() + "\": " + param.getName())
                .collect(Collectors.joining(", ")) + "}";
    }

    public String typedefs() {
        StringBuilder builder = new StringBuilder();
        builder.append("//================ JSDoc typedef ========================//\n");
        for (Map.Entry<Class<?>, String> entry : javaBeanTypeDefMap.entrySet()) {
            Class<?> clazz = entry.getKey();
            builder.append("/**\n");
            builder.append("* @typedef {Object} " + entry.getValue() + "\n");
            for (Field field : clazz.getDeclaredFields()) {
                builder.append("* @property {" + toJsType(field.getType()) + "} " + field.getName() + "\n");
            }
            builder.append("*/\n");
        }
        //@typeDef for return type and parameter type
        Map<String, JSDocTypeDef> allTypeDefMap = new HashMap<>(this.customizedTypeDefMap);
        Map<String, JSDocTypeDef> typeDefForReturnTypeMap = jsHttpStubMethods.stream()
                .map(JsHttpStubMethod::getJsDocTypeDef)
                .filter(Objects::nonNull)
                .collect(Collectors.toMap(JSDocTypeDef::getName, jsDocTypeDef -> jsDocTypeDef, (a, b) -> b));
        allTypeDefMap.putAll(typeDefForReturnTypeMap);
        for (JSDocTypeDef jsDocTypeDef : allTypeDefMap.values()) {
            builder.append("/**\n");
            builder.append(" * @typedef {Object} " + jsDocTypeDef.getName() + "\n");
            for (String property : jsDocTypeDef.getProperties()) {
                String[] parts = property.split("\\s?:\\s+", 2);
                if (parts.length > 1) {
                    builder.append(" * @property {" + parts[1] + "} " + parts[0] + "\n");
                } else {
                    builder.append(" * @property " + parts[0] + "\n");
                }
            }
            builder.append(" */\n");
        }
        return builder.toString();
    }

}
